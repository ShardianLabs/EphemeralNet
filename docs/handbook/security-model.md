# Security model

EphemeralNet enforces multiple layers of defense to keep the TTL-focused network usable even in untrusted environments. This chapter documents the mechanisms implemented today so auditors and contributors can reason about trust boundaries.

## Identities and key material

- **Peer IDs** (`ephemeralnet::PeerId`) are 32-byte values derived from SHA-256 of the deterministic identity scalar. `Node::generate_identity_scalar()` seeds a `std::mt19937` with `identity_seed` (if provided) or a hardware RNG, then computes the Diffie-Hellman public key via `network::KeyExchange::compute_public`.
- **Session keys** are derived from the shared Diffie-Hellman scalar (`KeyExchange::derive_shared_secret`) and hashed with SHA-256 to produce a 256-bit ChaCha20 key.
- **Key rotation** happens every `key_rotation_interval` (default 5 minutes). `Node::tick()` asks `SessionManager` to tear down stale sessions so long-lived peers must re-handshake, refreshing entropy.

## Transport confidentiality and authenticity

- Payload encryption uses ChaCha20 (`crypto::ChaCha20::apply`). Each message gets a fresh random nonce generated by `SessionManager` before encryption, preventing nonce reuse.
- Protocol frames (ANNOUNCE/REQUEST/CHUNK/ACK, handshake messages) can be encoded with `protocol::encode_signed`, which appends an HMAC-SHA256 computed over the plaintext bytes using the shared key. `decode_signed` verifies the MAC before decoding, dropping tampered data.
- The initial handshake is authenticated by proof-of-work (see below) and by verifying that the peer knows the correct shared secret (since only peers with the right private keys can derive it).

## Proof-of-work controls

Proof-of-work combats spam on three surfaces:

1. **Transport handshake PoW** (`Config::handshake_pow_difficulty`, default 4 bits). During `SessionManager::connect`, the initiator solves a nonce over (initiator ID, responder ID, public scalar). The responder recomputes the digest via `handshake_pow_digest` and counts leading zeros before accepting.
2. **ANNOUNCE PoW** (`Config::announce_pow_difficulty`, default 6 bits). `Node` iteratively mutates `AnnouncePayload::work_nonce` until the SHA-256 digest of chunk ID + peer ID + endpoint + manifest URI + shard list + TTL meets the configured difficulty. Receiving peers reject ANNOUNCE messages that fail validation, which makes poisoning expensive.
3. **STORE PoW** (`Config::store_pow_difficulty`, default 6 bits). The CLI calculates a 64-bit nonce over the chunk ID, payload size, and sanitized filename. `security::StoreProof` ensures uploads without a valid nonce are rejected (`ERR_STORE_POW_REQUIRED` / `ERR_STORE_POW_INVALID`). Repeated failures trigger temporary lockouts to slow brute-force attempts.

Manifests expose the active handshake/store difficulties via the security advisory text so offline solvers know the target.

## Control-plane protections

- `control_token`: optional bearer secret validated per connection using constant-time comparison (`constant_time_equal`). When combined with `--control-expose`, this prevents unauthenticated remote management.
- Rate limiting: `ControlServer` tracks per-command windows (`kStoreRateWindow`, `kFetchStreamRateWindow`) so bursts of uploads or fetches cannot starve other clients.
- Payload limits: `PAYLOAD-LENGTH` is capped by `control_stream_max_bytes` (default 32 MiB) and validated before the daemon reads a single byte.
- Structured logging: sensitive values (tokens, file contents) are never printed; logs focus on metadata, exit codes, and diagnostics to avoid leaking secrets.

## Data at rest

- In-memory chunks are encrypted until they leave `ChunkStore`; once decrypted for a fetch, they are never written back to disk unless persistence is enabled.
- Persistent chunks are overwritten (configurable number of passes) before deletion to reduce the chance of recovery from disk snapshots.
- Manifest metadata only stores the original filename if the CLI uploads from disk; operators can disable this by passing `--fetch-ignore-manifest-name` on fetch or sanitizing uploads beforehand.

## Abuse mitigation and reputation

- `network::ReputationManager` keeps per-peer scores (seed roles, leecher roles, choke state). `SwarmCoordinator` uses those scores when deciding who receives future shards, favouring honest peers.
- `Node` tracks PoW failures and exposes them through `Node::PowStatistics`; the control plane surfaces these counters via `METRICS` so operators can alert on suspicious spikes (Grafana dashboard JSON lives in `docs/observability/`).
- CLI commands prompt before dangerous actions (`--control-expose`, overwriting files) unless `--yes` is provided, preventing accidental leaks during automation.

## Trust boundaries

- The CLI trusts the local daemon but not remote peers; it verifies all daemon responses via status codes and hints.
- The daemon trusts only localhost by default; remote control requires an explicit `--control-expose` + `--control-token` pairing.
- Data-plane peers are treated as untrusted. Encryption, PoW, TTL, and reputation scoring defend against malicious or flaky participants. No long-lived secrets traverse the network; manifests expose only what is necessary to fetch the data before TTL expiry.

Future development (e.g., mutual TLS, hardware attestation) can build on this foundation by plugging into the clearly defined hooks inside `Node`, `SessionManager`, and the control plane.
